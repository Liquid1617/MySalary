const express = require('express');
const router = express.Router();
const { User, Account, Currency, Transaction } = require('../db/models');
const exchangeRateService = require('../services/exchangeRate');
const authMiddleware = require('../middleware/auth');
const { Op, Sequelize } = require('sequelize');

// –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö net worth –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 7 –¥–Ω–µ–π –¥–ª—è –≥—Ä–∞—Ñ–∏–∫–∞
router.get('/chart', authMiddleware, async (req, res) => {
  try {
    console.log('=== CHART API REQUEST ===');
    console.log('User ID:', req.user.id);
    
    const user = await User.findByPk(req.user.id, {
      include: [
        {
          model: Currency,
          as: 'primaryCurrency',
          attributes: ['code', 'name', 'symbol']
        }
      ]
    });

    if (!user || !user.primaryCurrency) {
      console.log('‚ùå User or currency not found');
      return res.status(404).json({ error: 'User or currency not found' });
    }

    console.log('‚úÖ User found:', user.id, 'Primary currency:', user.primaryCurrency.code);

    // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ —Å—á–µ—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const accounts = await Account.findAll({
      where: {
        user_id: req.user.id,
        is_active: true
      },
      include: [
        {
          model: Currency,
          as: 'currency',
          attributes: ['code', 'name', 'symbol']
        }
      ]
    });

    console.log('üìä Found accounts:', accounts.length);
    accounts.forEach(account => {
      console.log(`  - ${account.account_name}: ${account.balance} ${account.currency.code}`);
    });

    if (accounts.length === 0) {
      console.log('‚ùå No accounts found, returning empty data');
      // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç—ã–µ –¥–∞–Ω–Ω—ã–µ –µ—Å–ª–∏ –Ω–µ—Ç —Å—á–µ—Ç–æ–≤
      return res.json({
        labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
        datasets: [
          {
            data: [0, 0, 0, 0, 0, 0, 0],
          },
        ],
      });
    }

    // –°–æ–∑–¥–∞–µ–º –º–∞—Å—Å–∏–≤ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö 7 –¥–Ω–µ–π
    const dates = [];
    const labels = [];
    const today = new Date();
    
    for (let i = 6; i >= 0; i--) {
      const date = new Date(today);
      date.setDate(today.getDate() - i);
      dates.push(date.toISOString().split('T')[0]); // YYYY-MM-DD format
      
      const dayName = date.toLocaleDateString('en-US', { weekday: 'short' });
      labels.push(dayName);
    }

    console.log('üìÖ Date range:', dates[0], 'to', dates[dates.length - 1]);

    // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –¥–æ –∫–æ–Ω—Ü–∞ –ø–µ—Ä–∏–æ–¥–∞
    const { Transaction } = require('../db/models');
    const endDate = dates[dates.length - 1];
    
    const transactions = await Transaction.findAll({
      where: {
        user_id: req.user.id,
        transaction_date: {
          [Op.lte]: endDate
        },
        status: 'posted' // –ò—Å–∫–ª—é—á–∞–µ–º scheduled —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
      },
      include: [
        {
          model: Account,
          as: 'account',
          attributes: ['id', 'currency_id'],
          include: [
            {
              model: Currency,
              as: 'currency',
              attributes: ['code']
            }
          ]
        }
      ],
      order: [['createdAt', 'ASC']]
    });

    console.log('üí∞ Found transactions:', transactions.length);
    transactions.forEach(transaction => {
      console.log(`  - ${transaction.transaction_date}: ${transaction.transaction_type} ${transaction.amount} ${transaction.account.currency.code}`);
    });

    // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –ø–æ –¥–Ω—è–º
    const transactionsByDate = {};
    transactions.forEach(transaction => {
      const date = transaction.transaction_date;
      if (!transactionsByDate[date]) {
        transactionsByDate[date] = [];
      }
      transactionsByDate[date].push(transaction);
    });

    // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º net worth –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –¥–Ω—è
    const chartData = [];
    let cumulativeNetWorth = 0;

    // –ü–æ–ª—É—á–∞–µ–º –∫—É—Ä—Å—ã –≤–∞–ª—é—Ç –¥–ª—è –æ—Å–Ω–æ–≤–Ω–æ–π –≤–∞–ª—é—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const exchangeRates = await exchangeRateService.getExchangeRates(user.primaryCurrency.code);

    for (const date of dates) {
      // –î–æ–±–∞–≤–ª—è–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ —ç—Ç–æ–≥–æ –¥–Ω—è –∫ –Ω–∞–∫–æ–ø–∏—Ç–µ–ª—å–Ω–æ–º—É net worth
      if (transactionsByDate[date]) {
        console.log(`üíµ Processing transactions for ${date}:`);
        for (const transaction of transactionsByDate[date]) {
          let amount = parseFloat(transaction.amount) || 0;
          
          // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ –æ—Å–Ω–æ–≤–Ω—É—é –≤–∞–ª—é—Ç—É –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
          const transactionCurrency = transaction.account.currency.code;
          if (transactionCurrency !== user.primaryCurrency.code) {
            try {
              amount = await exchangeRateService.convertCurrency(
                amount,
                transactionCurrency,
                user.primaryCurrency.code,
                exchangeRates
              );
            } catch (error) {
              console.error(`Error converting ${transactionCurrency} to ${user.primaryCurrency.code}:`, error);
              // –ò—Å–ø–æ–ª—å–∑—É–µ–º fallback –∫—É—Ä—Å
              const fallbackRate = exchangeRates[transactionCurrency] || 1;
              amount = amount / fallbackRate;
            }
          }

          if (transaction.transaction_type === 'income') {
            cumulativeNetWorth += amount;
            console.log(`    +${amount} (income) = ${cumulativeNetWorth}`);
          } else if (transaction.transaction_type === 'expense') {
            cumulativeNetWorth -= amount;
            console.log(`    -${amount} (expense) = ${cumulativeNetWorth}`);
          }
        }
      }
      
      const dayValue = Math.max(0, Math.round(cumulativeNetWorth));
      chartData.push(dayValue);
      console.log(`üìà ${date} (${labels[dates.indexOf(date)]}): ${dayValue}`);
    }

    // –ï—Å–ª–∏ –≤—Å–µ –∑–Ω–∞—á–µ–Ω–∏—è 0, —Å–æ–∑–¥–∞–µ–º –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    if (chartData.every(value => value === 0)) {
      console.log('‚ö†Ô∏è All chart values are 0, using demo data based on account balances');
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—É—â–∏–µ –±–∞–ª–∞–Ω—Å—ã —Å—á–µ—Ç–æ–≤ –∫–∞–∫ –±–∞–∑—É –¥–ª—è –¥–µ–º–æ-–¥–∞–Ω–Ω—ã—Ö
      let totalBalance = 0;
      for (const account of accounts) {
        totalBalance += parseFloat(account.balance) || 0;
      }
      
      console.log('üí∞ Total account balance:', totalBalance);
      const baseAmount = Math.max(1000, totalBalance);
      chartData.splice(0, chartData.length, 
        Math.round(baseAmount * 0.85),
        Math.round(baseAmount * 0.92),
        Math.round(baseAmount * 0.88),
        Math.round(baseAmount * 0.95),
        Math.round(baseAmount * 1.08),
        Math.round(baseAmount * 1.02),
        Math.round(baseAmount)
      );
      console.log('üìä Demo chart data:', chartData);
    }

    const result = {
      labels: labels,
      datasets: [
        {
          data: chartData,
        },
      ],
    };

    console.log('üéØ FINAL RESULT:', JSON.stringify(result));
    console.log('=== END CHART API REQUEST ===');

    res.json(result);

  } catch (error) {
    console.error('‚ùå Error fetching net worth chart data:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// GET /api/networth - get user's total balance in primary currency
router.get('/', authMiddleware, async (req, res) => {
  try {
    // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –µ–≥–æ –æ—Å–Ω–æ–≤–Ω–æ–π –≤–∞–ª—é—Ç–æ–π
    const user = await User.findByPk(req.user.id, {
      include: [
        {
          model: Currency,
          as: 'primaryCurrency',
          attributes: ['id', 'code', 'name', 'symbol']
        }
      ]
    });

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    // –ï—Å–ª–∏ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–µ—Ç –æ—Å–Ω–æ–≤–Ω–æ–π –≤–∞–ª—é—Ç—ã, —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º USD –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    let primaryCurrency = user.primaryCurrency;
    if (!primaryCurrency) {
      const usdCurrency = await Currency.findOne({ where: { code: 'USD' } });
      if (usdCurrency) {
        await user.update({ primary_currency_id: usdCurrency.id });
        primaryCurrency = usdCurrency;
      }
    }

    if (!primaryCurrency) {
      return res.status(500).json({ error: 'Could not determine primary currency' });
    }

    // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ —Å—á–µ—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const accounts = await Account.findAll({
      where: { 
        user_id: req.user.id,
        is_active: true 
      },
      include: [
        {
          model: Currency,
          as: 'currency',
          attributes: ['id', 'code', 'name', 'symbol']
        }
      ]
    });

    if (accounts.length === 0) {
      return res.json({
        netWorth: 0,
        primaryCurrency: primaryCurrency,
        accounts: [],
        message: 'You have no active accounts yet'
      });
    }

    // –ü–æ–ª—É—á–∞–µ–º –∫—É—Ä—Å—ã –≤–∞–ª—é—Ç –¥–ª—è –æ—Å–Ω–æ–≤–Ω–æ–π –≤–∞–ª—é—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const exchangeRates = await exchangeRateService.getExchangeRates(primaryCurrency.code);

    let totalNetWorth = 0;
    const accountsData = [];

    // –ü–æ–ª—É—á–∞–µ–º –±—É–¥—É—â–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∏ –±–∞–ª–∞–Ω—Å–æ–≤
    const today = new Date().toISOString().slice(0, 10);
    const { Op } = require('sequelize');
    
    const scheduledTransactions = await Transaction.findAll({
      where: {
        '$account.user_id$': req.user.id,
        status: 'scheduled' // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞—Ç—É—Å –≤–º–µ—Å—Ç–æ –¥–∞—Ç—ã
      },
      include: [{
        model: Account,
        as: 'account',
        where: { is_active: true }
      }]
    });

    // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º scheduled —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –ø–æ —Å—á–µ—Ç–∞–º
    const scheduledTransactionsByAccount = {};
    for (const transaction of scheduledTransactions) {
      const accountId = transaction.account_id;
      if (!scheduledTransactionsByAccount[accountId]) {
        scheduledTransactionsByAccount[accountId] = 0;
      }
      
      // –í—ã—á–∏—Å–ª—è–µ–º –≤–ª–∏—è–Ω–∏–µ scheduled —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –Ω–∞ –±–∞–ª–∞–Ω—Å
      const impact = transaction.transaction_type === 'income' 
        ? parseFloat(transaction.amount) 
        : -parseFloat(transaction.amount);
      
      scheduledTransactionsByAccount[accountId] += impact;
    }

    console.log('üìä Scheduled transactions impact by account:', scheduledTransactionsByAccount);

    // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –∫–∞–∂–¥—ã–π —Å—á–µ—Ç –≤ –æ—Å–Ω–æ–≤–Ω—É—é –≤–∞–ª—é—Ç—É
    for (const account of accounts) {
      const accountCurrency = account.currency.code;
      let accountBalance = parseFloat(account.balance) || 0;
      
      // –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –±–∞–ª–∞–Ω—Å, –∏—Å–∫–ª—é—á–∞—è scheduled —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
      if (scheduledTransactionsByAccount[account.id]) {
        const scheduledImpact = scheduledTransactionsByAccount[account.id];
        accountBalance -= scheduledImpact;
        console.log(`üí∞ Account ${account.account_name}: ${account.balance} -> ${accountBalance} (excluding scheduled: ${scheduledImpact})`);
      }
      
      let convertedBalance = accountBalance;
      
      if (accountCurrency !== primaryCurrency.code) {
        try {
          convertedBalance = await exchangeRateService.convertCurrency(
            accountBalance,
            accountCurrency,
            primaryCurrency.code,
            exchangeRates
          );
        } catch (error) {
          console.error(`Error converting ${accountCurrency} to ${primaryCurrency.code}:`, error);
          // In case of conversion error, use fallback
          const fallbackRate = exchangeRates[accountCurrency] || 1;
          convertedBalance = accountBalance / fallbackRate;
        }
      }

      totalNetWorth += convertedBalance;

      accountsData.push({
        id: account.id,
        name: account.account_name,
        type: account.account_type,
        originalBalance: accountBalance,
        originalCurrency: {
          code: account.currency.code,
          symbol: account.currency.symbol
        },
        convertedBalance: convertedBalance,
        exchangeRate: accountCurrency === primaryCurrency.code ? 1 : (exchangeRates[accountCurrency] || 1)
      });
    }

    res.json({
      netWorth: Math.round(totalNetWorth * 100) / 100, // Round to 2 decimal places
      primaryCurrency: primaryCurrency,
      accounts: accountsData,
      exchangeRatesTimestamp: Date.now(),
      message: accounts.length === 1 ? 
        `Your total balance from ${accounts.length} account` : 
        `Your total balance from ${accounts.length} accounts`
    });

  } catch (error) {
    console.error('Error calculating Net Worth:', error);
    res.status(500).json({ error: 'Server error calculating total balance' });
  }
});

// PUT /api/networth/currency - –∏–∑–º–µ–Ω–∏—Ç—å –æ—Å–Ω–æ–≤–Ω—É—é –≤–∞–ª—é—Ç—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
router.put('/currency', authMiddleware, async (req, res) => {
  try {
    const { currency_id } = req.body;

    if (!currency_id) {
      return res.status(400).json({ error: 'currency_id is required' });
    }

    // Check if currency exists
    const currency = await Currency.findByPk(currency_id);
    if (!currency) {
      return res.status(404).json({ error: 'Currency not found' });
    }

    // Update user's primary currency
    await User.update(
      { primary_currency_id: currency_id },
      { where: { id: req.user.id } }
    );

    res.json({
      message: 'Primary currency successfully updated',
      primaryCurrency: currency
    });

  } catch (error) {
    console.error('Error changing primary currency:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

module.exports = router; 